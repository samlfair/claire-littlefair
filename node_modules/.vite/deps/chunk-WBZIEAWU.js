import {
  __commonJS,
  __objRest,
  __spreadProps,
  __spreadValues,
  __toESM
} from "./chunk-WWO6H54A.js";

// node_modules/escape-html/index.js
var require_escape_html = __commonJS({
  "node_modules/escape-html/index.js"(exports, module) {
    "use strict";
    var matchHtmlRegExp = /["'&<>]/;
    module.exports = escapeHtml2;
    function escapeHtml2(string) {
      var str = "" + string;
      var match = matchHtmlRegExp.exec(str);
      if (!match) {
        return str;
      }
      var escape;
      var html = "";
      var index = 0;
      var lastIndex = 0;
      for (index = match.index; index < str.length; index++) {
        switch (str.charCodeAt(index)) {
          case 34:
            escape = "&quot;";
            break;
          case 38:
            escape = "&amp;";
            break;
          case 39:
            escape = "&#39;";
            break;
          case 60:
            escape = "&lt;";
            break;
          case 62:
            escape = "&gt;";
            break;
          default:
            continue;
        }
        if (lastIndex !== index) {
          html += str.substring(lastIndex, index);
        }
        lastIndex = index + 1;
        html += escape;
      }
      return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
    }
  }
});

// node_modules/@prismicio/types/dist/index.js
var RichTextNodeType = {
  heading1: "heading1",
  heading2: "heading2",
  heading3: "heading3",
  heading4: "heading4",
  heading5: "heading5",
  heading6: "heading6",
  paragraph: "paragraph",
  preformatted: "preformatted",
  strong: "strong",
  em: "em",
  listItem: "list-item",
  oListItem: "o-list-item",
  list: "group-list-item",
  oList: "group-o-list-item",
  image: "image",
  embed: "embed",
  hyperlink: "hyperlink",
  label: "label",
  span: "span"
};
var LinkType = {
  Any: "Any",
  Document: "Document",
  Media: "Media",
  Web: "Web"
};

// node_modules/@prismicio/richtext/dist/index.js
var uuid = () => {
  return (++uuid.i).toString();
};
uuid.i = 0;
var asTree = (nodes) => {
  const preparedNodes = prepareNodes(nodes);
  const children = [];
  for (let i = 0; i < preparedNodes.length; i++) {
    children.push(nodeToTreeNode(preparedNodes[i]));
  }
  return {
    key: uuid(),
    children
  };
};
var createTreeNode = (node, children = []) => {
  return {
    key: uuid(),
    type: node.type,
    text: "text" in node ? node.text : void 0,
    node,
    children
  };
};
var createTextTreeNode = (text) => {
  return createTreeNode({
    type: RichTextNodeType.span,
    text,
    spans: []
  });
};
var prepareNodes = (nodes) => {
  const mutNodes = nodes.slice(0);
  for (let i = 0; i < mutNodes.length; i++) {
    const node = mutNodes[i];
    if (node.type === RichTextNodeType.listItem || node.type === RichTextNodeType.oListItem) {
      const items = [
        node
      ];
      while (mutNodes[i + 1] && mutNodes[i + 1].type === node.type) {
        items.push(mutNodes[i + 1]);
        mutNodes.splice(i, 1);
      }
      if (node.type === RichTextNodeType.listItem) {
        mutNodes[i] = {
          type: RichTextNodeType.list,
          items
        };
      } else {
        mutNodes[i] = {
          type: RichTextNodeType.oList,
          items
        };
      }
    }
  }
  return mutNodes;
};
var nodeToTreeNode = (node) => {
  if ("text" in node) {
    return createTreeNode(node, textNodeSpansToTreeNodeChildren(node.spans, node));
  }
  if ("items" in node) {
    const children = [];
    for (let i = 0; i < node.items.length; i++) {
      children.push(nodeToTreeNode(node.items[i]));
    }
    return createTreeNode(node, children);
  }
  return createTreeNode(node);
};
var textNodeSpansToTreeNodeChildren = (spans, node, parentSpan) => {
  if (!spans.length) {
    return [createTextTreeNode(node.text)];
  }
  const mutSpans = spans.slice(0);
  mutSpans.sort((a, b) => a.start - b.start || b.end - a.end);
  const children = [];
  for (let i = 0; i < mutSpans.length; i++) {
    const span = mutSpans[i];
    const parentSpanStart = parentSpan && parentSpan.start || 0;
    const spanStart = span.start - parentSpanStart;
    const spanEnd = span.end - parentSpanStart;
    const text = node.text.slice(spanStart, spanEnd);
    const childSpans = [];
    for (let j = i; j < mutSpans.length; j++) {
      const siblingSpan = mutSpans[j];
      if (siblingSpan !== span && siblingSpan.start >= span.start && siblingSpan.end <= span.end) {
        childSpans.push(siblingSpan);
        mutSpans.splice(j, 1);
        j--;
      }
    }
    if (i === 0 && spanStart > 0) {
      children.push(createTextTreeNode(node.text.slice(0, spanStart)));
    }
    const spanWithText = __spreadProps(__spreadValues({}, span), { text });
    children.push(createTreeNode(spanWithText, textNodeSpansToTreeNodeChildren(childSpans, __spreadProps(__spreadValues({}, node), {
      text
    }), span)));
    if (spanEnd < node.text.length) {
      children.push(createTextTreeNode(node.text.slice(spanEnd, mutSpans[i + 1] ? mutSpans[i + 1].start - parentSpanStart : void 0)));
    }
  }
  return children;
};
var asText = (richTextField, separator = " ") => {
  let result = "";
  for (let i = 0; i < richTextField.length; i++) {
    if ("text" in richTextField[i]) {
      result += (result ? separator : "") + richTextField[i].text;
    }
  }
  return result;
};
var serialize = (richTextField, serializer) => {
  return serializeTreeNodes(asTree(richTextField).children, serializer);
};
var serializeTreeNodes = (nodes, serializer) => {
  const serializedTreeNodes = [];
  for (let i = 0; i < nodes.length; i++) {
    const treeNode = nodes[i];
    const serializedTreeNode = serializer(treeNode.type, treeNode.node, treeNode.text, serializeTreeNodes(treeNode.children, serializer), treeNode.key);
    if (serializedTreeNode != null) {
      serializedTreeNodes.push(serializedTreeNode);
    }
  }
  return serializedTreeNodes;
};
var RichTextReversedNodeType = {
  [RichTextNodeType.listItem]: "listItem",
  [RichTextNodeType.oListItem]: "oListItem",
  [RichTextNodeType.list]: "list",
  [RichTextNodeType.oList]: "oList"
};
var wrapMapSerializer = (mapSerializer) => {
  return (type, node, text, children, key) => {
    const tagSerializer = mapSerializer[RichTextReversedNodeType[type] || type];
    if (tagSerializer) {
      return tagSerializer({
        type,
        node,
        text,
        children,
        key
      });
    }
  };
};
var composeSerializers = (...serializers) => {
  return (...args) => {
    for (let i = 0; i < serializers.length; i++) {
      const serializer = serializers[i];
      if (serializer) {
        const res = serializer(...args);
        if (res != null) {
          return res;
        }
      }
    }
  };
};

// node_modules/@prismicio/helpers/dist/index.js
var import_escape_html = __toESM(require_escape_html(), 1);

// node_modules/imgix-url-builder/dist/index.mjs
var camelCaseToParamCase = (input) => {
  return input.replace(/[A-Z]/g, (match) => {
    return `-${match.toLowerCase()}`;
  });
};
var buildURL = (url, params) => {
  const instance = new URL(url);
  for (const camelCasedParamKey in params) {
    const paramKey = camelCaseToParamCase(camelCasedParamKey);
    const paramValue = params[camelCasedParamKey];
    if (paramValue === void 0) {
      instance.searchParams.delete(paramKey);
    } else if (Array.isArray(paramValue)) {
      instance.searchParams.set(paramKey, paramValue.join(","));
    } else {
      instance.searchParams.set(paramKey, `${paramValue}`);
    }
  }
  const s = instance.searchParams.get("s");
  if (s) {
    instance.searchParams.delete("s");
    instance.searchParams.append("s", s);
  }
  return instance.toString();
};
var buildPixelDensitySrcSet = (url, _a) => {
  var _b = _a, { pixelDensities } = _b, params = __objRest(_b, ["pixelDensities"]);
  return pixelDensities.map((dpr) => {
    return `${buildURL(url, __spreadProps(__spreadValues({}, params), { dpr }))} ${dpr}x`;
  }).join(", ");
};
var buildWidthSrcSet = (url, _a) => {
  var _b = _a, { widths } = _b, params = __objRest(_b, ["widths"]);
  return widths.map((width) => {
    return `${buildURL(url, __spreadProps(__spreadValues({}, params), { w: void 0, width }))} ${width}w`;
  }).join(", ");
};

// node_modules/@prismicio/helpers/dist/index.js
var asDate = (dateOrTimestampField) => {
  if (!dateOrTimestampField) {
    return null;
  }
  if (dateOrTimestampField.length === 24) {
    return new Date(dateOrTimestampField.replace(/(\+|-)(\d{2})(\d{2})$/, ".000$1$2:$3"));
  } else {
    return new Date(dateOrTimestampField);
  }
};
var documentToLinkField = (prismicDocument) => {
  var _a, _b, _c;
  return __spreadValues({
    link_type: LinkType.Document,
    id: prismicDocument.id,
    uid: (_a = prismicDocument.uid) != null ? _a : void 0,
    type: prismicDocument.type,
    tags: prismicDocument.tags,
    lang: prismicDocument.lang,
    url: (_b = prismicDocument.url) != null ? _b : void 0,
    slug: (_c = prismicDocument.slugs) == null ? void 0 : _c[0]
  }, Object.keys(prismicDocument.data).length > 0 ? { data: prismicDocument.data } : {});
};
var asLink = (linkFieldOrDocument, linkResolver) => {
  if (!linkFieldOrDocument) {
    return null;
  }
  const linkField = "link_type" in linkFieldOrDocument ? linkFieldOrDocument : documentToLinkField(linkFieldOrDocument);
  switch (linkField.link_type) {
    case LinkType.Media:
    case LinkType.Web:
      return "url" in linkField ? linkField.url : null;
    case LinkType.Document: {
      if ("id" in linkField && linkResolver) {
        const resolvedURL = linkResolver(linkField);
        if (resolvedURL != null) {
          return resolvedURL;
        }
      }
      if ("url" in linkField && linkField.url) {
        return linkField.url;
      }
      return null;
    }
    case LinkType.Any:
    default:
      return null;
  }
};
var asText2 = (richTextField, separator) => {
  if (richTextField) {
    return asText(richTextField, separator);
  } else {
    return null;
  }
};
var getLabel = (node) => {
  return "data" in node && "label" in node.data ? ` class="${node.data.label}"` : "";
};
var serializeStandardTag = (tag, node, children) => {
  return `<${tag}${getLabel(node)}>${children.join("")}</${tag}>`;
};
var serializePreFormatted = (node) => {
  return `<pre${getLabel(node)}>${(0, import_escape_html.default)(node.text)}</pre>`;
};
var serializeImage = (linkResolver, node) => {
  let imageTag = `<img src="${node.url}" alt="${(0, import_escape_html.default)(node.alt)}"${node.copyright ? ` copyright="${(0, import_escape_html.default)(node.copyright)}"` : ""} />`;
  if (node.linkTo) {
    imageTag = serializeHyperlink(linkResolver, {
      type: RichTextNodeType.hyperlink,
      data: node.linkTo,
      start: 0,
      end: 0
    }, [imageTag]);
  }
  return `<p class="block-img">${imageTag}</p>`;
};
var serializeEmbed = (node) => {
  return `<div data-oembed="${node.oembed.embed_url}" data-oembed-type="${node.oembed.type}" data-oembed-provider="${node.oembed.provider_name}"${getLabel(node)}>${node.oembed.html}</div>`;
};
var serializeHyperlink = (linkResolver, node, children) => {
  switch (node.data.link_type) {
    case LinkType.Web: {
      return `<a href="${(0, import_escape_html.default)(node.data.url)}" target="${node.data.target}" rel="noopener noreferrer"${getLabel(node)}>${children.join("")}</a>`;
    }
    case LinkType.Document: {
      return `<a href="${asLink(node.data, linkResolver)}"${getLabel(node)}>${children.join("")}</a>`;
    }
    case LinkType.Media: {
      return `<a href="${node.data.url}"${getLabel(node)}>${children.join("")}</a>`;
    }
  }
};
var serializeSpan = (content) => {
  return content ? (0, import_escape_html.default)(content).replace(/\n/g, "<br />") : "";
};
var createDefaultHTMLSerializer = (linkResolver) => {
  return (_type, node, text, children, _key) => {
    switch (node.type) {
      case RichTextNodeType.heading1:
        return serializeStandardTag("h1", node, children);
      case RichTextNodeType.heading2:
        return serializeStandardTag("h2", node, children);
      case RichTextNodeType.heading3:
        return serializeStandardTag("h3", node, children);
      case RichTextNodeType.heading4:
        return serializeStandardTag("h4", node, children);
      case RichTextNodeType.heading5:
        return serializeStandardTag("h5", node, children);
      case RichTextNodeType.heading6:
        return serializeStandardTag("h6", node, children);
      case RichTextNodeType.paragraph:
        return serializeStandardTag("p", node, children);
      case RichTextNodeType.preformatted:
        return serializePreFormatted(node);
      case RichTextNodeType.strong:
        return serializeStandardTag("strong", node, children);
      case RichTextNodeType.em:
        return serializeStandardTag("em", node, children);
      case RichTextNodeType.listItem:
        return serializeStandardTag("li", node, children);
      case RichTextNodeType.oListItem:
        return serializeStandardTag("li", node, children);
      case RichTextNodeType.list:
        return serializeStandardTag("ul", node, children);
      case RichTextNodeType.oList:
        return serializeStandardTag("ol", node, children);
      case RichTextNodeType.image:
        return serializeImage(linkResolver, node);
      case RichTextNodeType.embed:
        return serializeEmbed(node);
      case RichTextNodeType.hyperlink:
        return serializeHyperlink(linkResolver, node, children);
      case RichTextNodeType.label:
        return serializeStandardTag("span", node, children);
      case RichTextNodeType.span:
      default:
        return serializeSpan(text);
    }
  };
};
var wrapMapSerializerWithStringChildren = (mapSerializer) => {
  const modifiedMapSerializer = {};
  for (const tag in mapSerializer) {
    const tagSerializer = mapSerializer[tag];
    if (tagSerializer) {
      modifiedMapSerializer[tag] = (payload) => {
        return tagSerializer(__spreadProps(__spreadValues({}, payload), {
          children: payload.children.join("")
        }));
      };
    }
  }
  return wrapMapSerializer(modifiedMapSerializer);
};
var asHTML = (richTextField, linkResolver, htmlSerializer) => {
  if (richTextField) {
    let serializer;
    if (htmlSerializer) {
      serializer = composeSerializers(typeof htmlSerializer === "object" ? wrapMapSerializerWithStringChildren(htmlSerializer) : (type, node, text, children, key) => htmlSerializer(type, node, text, children.join(""), key), createDefaultHTMLSerializer(linkResolver));
    } else {
      serializer = createDefaultHTMLSerializer(linkResolver);
    }
    return serialize(richTextField, serializer).join("");
  } else {
    return null;
  }
};
var isNonNullish = (input) => {
  return input != null;
};
var isNonEmptyArray = (input) => {
  return !!input.length;
};
var richText = (field) => {
  if (!isNonNullish(field)) {
    return false;
  } else if (field.length === 1 && "text" in field[0]) {
    return !!field[0].text;
  } else {
    return !!field.length;
  }
};
var title = richText;
var imageThumbnail = (thumbnail) => {
  return isNonNullish(thumbnail) && !!thumbnail.url;
};
var image = imageThumbnail;
var link = (field) => {
  return isNonNullish(field) && ("id" in field || "url" in field);
};
var linkToMedia = link;
var contentRelationship = link;
var date = isNonNullish;
var timestamp = isNonNullish;
var color = isNonNullish;
var number = isNonNullish;
var keyText = (field) => {
  return isNonNullish(keyText) && !!field;
};
var select = isNonNullish;
var embed = (field) => {
  return isNonNullish(field) && !!field.embed_url;
};
var geoPoint = (field) => {
  return isNonNullish(field) && "longitude" in field;
};
var integrationFields = isNonNullish;
var group = (group2) => {
  return isNonNullish(group2) && isNonEmptyArray(group2);
};
var sliceZone = (slices) => {
  return isNonNullish(slices) && isNonEmptyArray(slices);
};
var isFilled = Object.freeze({
  __proto__: null,
  richText,
  title,
  imageThumbnail,
  image,
  link,
  linkToMedia,
  contentRelationship,
  date,
  timestamp,
  color,
  number,
  keyText,
  select,
  embed,
  geoPoint,
  integrationFields,
  group,
  sliceZone
});
var asImageSrc = (field, params = {}) => {
  if (field && imageThumbnail(field)) {
    return buildURL(field.url, params);
  } else {
    return null;
  }
};
var DEFAULT_WIDTHS = [640, 828, 1200, 2048, 3840];
var asImageWidthSrcSet = (field, params = {}) => {
  if (field && imageThumbnail(field)) {
    let _a = params, {
      widths = DEFAULT_WIDTHS
    } = _a, imgixParams = __objRest(_a, [
      "widths"
    ]);
    const _b = field, {
      url,
      dimensions,
      alt: _alt,
      copyright: _copyright
    } = _b, responsiveViews = __objRest(_b, [
      "url",
      "dimensions",
      "alt",
      "copyright"
    ]);
    const responsiveViewObjects = Object.values(responsiveViews);
    if (widths === "thumbnails" && responsiveViewObjects.length < 1) {
      widths = DEFAULT_WIDTHS;
    }
    return {
      src: buildURL(url, imgixParams),
      srcset: widths === "thumbnails" ? [
        buildWidthSrcSet(url, __spreadProps(__spreadValues({}, imgixParams), {
          widths: [dimensions.width]
        })),
        ...responsiveViewObjects.map((thumbnail) => {
          return buildWidthSrcSet(thumbnail.url, __spreadProps(__spreadValues({}, imgixParams), {
            widths: [thumbnail.dimensions.width]
          }));
        })
      ].join(", ") : buildWidthSrcSet(field.url, __spreadProps(__spreadValues({}, imgixParams), {
        widths
      }))
    };
  } else {
    return null;
  }
};
var DEFAULT_PIXEL_DENSITIES = [1, 2, 3];
var asImagePixelDensitySrcSet = (field, params = {}) => {
  if (field && imageThumbnail(field)) {
    const _a = params, { pixelDensities = DEFAULT_PIXEL_DENSITIES } = _a, imgixParams = __objRest(_a, ["pixelDensities"]);
    return {
      src: buildURL(field.url, imgixParams),
      srcset: buildPixelDensitySrcSet(field.url, __spreadProps(__spreadValues({}, imgixParams), {
        pixelDensities
      }))
    };
  } else {
    return null;
  }
};
var Elements = RichTextNodeType;

export {
  RichTextNodeType,
  asDate,
  documentToLinkField,
  asLink,
  asText2 as asText,
  asHTML,
  isFilled,
  asImageSrc,
  asImageWidthSrcSet,
  asImagePixelDensitySrcSet,
  Elements
};
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */
//# sourceMappingURL=chunk-WBZIEAWU.js.map
